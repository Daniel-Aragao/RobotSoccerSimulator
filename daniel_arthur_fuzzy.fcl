FUNCTION_BLOCK fuzhoda

VAR_INPUT
	ballDist : REAL;
	ballAngle : REAL;
	ballX: REAL;
	ballY: REAL;
	
	goalDist : REAL;
	goalAngle : REAL;
//	sonicFront: REAL;
	sonicRight: REAL;
//	sonicBack: REAL;
	sonicLeft: REAL;
END_VAR

VAR_OUTPUT
	vX : REAL;
	vY : REAL;
END_VAR

FUZZIFY sonicRight
	TERM far := (-1, 1) (0, 0) (1, 1);
	TERM close := (-1,0) (-0.15, 0) (-0.1, 1) (0.1, 1) (0.15, 0) (1, 0);
END_FUZZIFY

FUZZIFY sonicLeft
	TERM far := (-1, 1) (0, 0) (1, 1);
	TERM close := (-1,0) (-0.15, 0) (-0.1, 1) (0.1, 1) (0.15, 0) (1, 0);
END_FUZZIFY

FUZZIFY goalDist
	TERM far := (-1, 1) (0, 0) (1, 1);
	TERM close := (-1,0) (-0.2, 0) (-0.1, 1) (0.1, 1) (0.2, 0) (1, 0);
END_FUZZIFY

FUZZIFY goalAngle
	TERM left := (0,0) (45, 1) (135, 1) (180, 0) (360, 0);
	TERM right := (0,0) (180, 0) (225, 1) (315, 1) (360, 0);
	TERM front := (0, 1) (45, 1) (90, 0) (270, 0) (315, 1) (360, 1);
END_FUZZIFY

FUZZIFY ballAngle
	TERM behind := (0, 0) (45,0) (135, 1) (225, 1) (315, 0) (360, 0);
	TERM left := (0,0) (45, 1) (135, 1) (180, 0) (360, 0);
	TERM right := (0,0) (180, 0) (225, 1) (315, 1) (360, 0);
	TERM front := (0, 1) (45, 1) (90, 0) (270, 0) (315, 1) (360, 1);
END_FUZZIFY

FUZZIFY ballX
	TERM far := (0, 0) (0.5, 0) (1, 1);
	TERM moderate := (0, 0) (0.5, 1) (1, 0);
	TERM close := (0, 1) (0.5, 0) (1, 0);
END_FUZZIFY

FUZZIFY ballY
	TERM far := (0, 0) (0.5, 0) (1, 1);
	TERM moderate := (0, 0) (0.5, 1) (1, 0);
	TERM close := (0, 1) (0.5, 0) (1, 0);
END_FUZZIFY

FUZZIFY ballDist
	TERM far := (-1, 1) (0, 0) (1, 1);
	TERM close := (-1,0) (0, 1) (1, 0);
END_FUZZIFY

DEFUZZIFY vX
	TERM fastN := (-1, 1) (-0.5, 0) (0, 0) (1, 0);
	TERM fastP := (-1,0) (0,0) (0.5, 0) (1, 1);
	TERM slowN  := (-1, 0) (-0.5, 1) (0, 0) (1, 0);
	TERM slowP := (-1,0) (0,0) (0.5, 1) (1, 0);
	
	METHOD : COG;
	DEFAULT := 0;
END_DEFUZZIFY

DEFUZZIFY vY
	TERM fastN := (-1, 1) (-0.5, 0) (0, 0) (1, 0);
	TERM fastP := (-1,0) (0,0) (0.5, 0) (1, 1);
	TERM slowN  := (-1, 0) (-0.5, 1) (0, 0) (1, 0);
	TERM slowP := (-1,0) (0,0) (0.5, 1) (1, 0);
	TERM no := (0,0);
	
	METHOD : COG;
	DEFAULT := 0;
END_DEFUZZIFY

RULEBLOCK velBollPos
	AND : MIN;	// Use 'min' for 'and'
	ACT : MIN;	// Use 'min' activation method
	ACCU : MAX;	// Use 'max' accumulation method
	
	RULE 1 : IF ballAngle IS front THEN vX IS fastP;
	RULE 2 : IF ballAngle IS behind THEN vX IS fastN;
	RULE 3 : IF ballAngle IS left THEN vY IS fastN;
	RULE 4 : IF ballAngle IS right THEN vY IS fastP;
	
//	RULE 5 : IF ballAngle IS left AND ballAngle IS behind THEN vY IS slowP;
//	RULE 6 : IF ballAngle IS right AND ballAngle IS behind THEN vY IS slowN;
	
	RULE 7 : IF ballX IS close AND ballY IS close AND ballAngle IS behind AND ballAngle IS left THEN vY IS no;
	RULE 8 : IF ballX IS close AND ballY IS close AND ballAngle IS behind AND ballAngle IS right THEN vY IS no;
	RULE 9 : IF ballX IS close AND ballY IS close AND ballAngle IS behind THEN vX IS fastN;
	
END_RULEBLOCK

RULEBLOCK GoalPos
	AND : MIN;	// Use 'min' for 'and'
	ACT : MIN;	// Use 'min' activation method
	ACCU : MAX;	// Use 'max' accumulation method
	
	RULE 1 : IF goalAngle IS right AND goalAngle IS front AND goalDist IS close THEN vY IS fastN;
	RULE 2 : IF goalAngle IS left AND goalAngle IS front AND goalDist IS close THEN vY IS fastP;
END_RULEBLOCK

//RULEBLOCK UltraSonic
//	AND : MIN;	// Use 'min' for 'and'
//	ACT : MIN;	// Use 'min' activation method
//	ACCU : MAX;	// Use 'max' accumulation method
//	
//	RULE 1 : IF sonicRight IS close THEN vY IS slowN;
//END_RULEBLOCK

// Fuzzify input variable 'service': {'poor', 'good' , 'excellent'}
//FUZZIFY service			
//	TERM poor := (0, 1) (4, 0) ; 
//	TERM good := (1, 0) (4,1) (6,1) (9,0);
//	TERM excellent := (6, 0) (9, 1);
//END_FUZZIFY

//// Defzzzify output variable 'tip' : {'cheap', 'average', 'generous' }
//DEFUZZIFY tip			
//	TERM cheap := (0,0) (5,1) (10,0);
//	TERM average := (10,0) (15,1) (20,0);
//	TERM generous := (20,0) (25,1) (30,0);
//	METHOD : COG;		// Use 'Center Of Gravity' defuzzification method
//	DEFAULT := 0;		// Default value is 0 (if no rule activates defuzzifier)
//END_DEFUZZIFY

// Inference rules
//RULEBLOCK No1
//	AND : MIN;	// Use 'min' for 'and'
//	ACT : MIN;	// Use 'min' activation method
//	ACCU : MAX;	// Use 'max' accumulation method
//
//	RULE 1 : IF service IS poor OR food IS rancid THEN tip IS cheap;
//	RULE 2 : IF service IS good THEN tip IS average; 
//	RULE 3 : IF service IS excellent AND food IS delicious THEN tip IS generous;
//END_RULEBLOCK

END_FUNCTION_BLOCK